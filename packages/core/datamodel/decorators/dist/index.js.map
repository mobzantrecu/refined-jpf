{"version":3,"sources":["../src/index.ts","../src/dataIndex.decorator.ts","../src/joinColumn.decorator.tsx","../src/key.decorator.ts","../src/render.decorator.ts","../src/renderCell.decorator.ts","../src/title.decorator.ts","../src/Ant/Entity.tsx","../src/Ant/internal/components/ShowComp.tsx"],"sourcesContent":["export {\n    dataIndex,\n    dataIndexKey,\n    dataIndexMetadataKey,\n} from './dataIndex.decorator';\nexport {\n    JoinColumn,\n    joinColumnKey,\n    joinColumnMetadataKey,\n} from './joinColumn.decorator';\nexport { key, keyKey, keyMetadataKey } from './key.decorator';\nexport { render, renderKey, renderMetadataKey } from './render.decorator';\nexport { renderCell, renderCellMetadataKey } from './renderCell.decorator';\nexport { title, titleKey, titleMetadataKey } from './title.decorator';\n\nexport {\n    AntdEntity,\n    antdEntityTableColumns,\n    antdEntityGetColumns,\n    antdEntityTableColumnsFromObj,\n    antdEntityGetShowFields,\n    ShowFields,\n    ShowFieldsType,\n} from './Ant/Entity';\n","import 'reflect-metadata';\n\nexport const dataIndexMetadataKey = Symbol('dataIndex');\nexport const dataIndexKey = 'dataIndex';\n\nexport function dataIndex(name: string): PropertyDecorator {\n    return Reflect.metadata(dataIndexMetadataKey, name);\n}\n","import 'reflect-metadata';\nimport React, { FunctionComponent } from 'react';\nimport { BaseKey, BaseRecord, useOne, useMany } from '@refinedev/core';\n\nexport const joinColumnMetadataKey = Symbol('JoinColumn');\nexport const joinColumnKey = 'render';\n\nfunction JoinColumn(\n    resource: string,\n    identification: string,\n    fieldToShow: string,\n    multiple?: boolean\n) {\n    const element = multiple ? JoinColumnMultipleFetch : JoinColumnFetch;\n    const returnElement = (item: any) => {\n        const hasIdentificationProperty = !!item[identification];\n        const isAnArrayOfIds = !!item.length;\n\n        const id =\n            isAnArrayOfIds && !hasIdentificationProperty\n                ? item\n                : item[identification];\n        return React.createElement(element, {\n            resource,\n            id,\n            fieldToShow,\n        }) as unknown as FunctionComponent<any>;\n    };\n\n    return Reflect.metadata(joinColumnMetadataKey, returnElement);\n}\n\n/**\n * @internal\n **/\nfunction JoinColumnMultipleFetch<T extends BaseRecord>({\n    resource,\n    id,\n    fieldToShow,\n}: {\n    resource: string;\n    id: BaseKey[];\n    fieldToShow: string;\n}): JSX.Element {\n    const { data: response, isLoading } = useMany<T>({\n        resource: resource,\n        ids: id,\n    });\n\n    const data = response?.data;\n\n    const filteredData = data?.map((x) => x[fieldToShow]);\n\n    return isLoading ? <>{'loading...'}</> : <>{filteredData?.join(', ')}</>;\n}\n\n/**\n * @internal\n **/\nfunction JoinColumnFetch<T extends BaseRecord>({\n    resource,\n    id,\n    fieldToShow,\n}: any): JSX.Element {\n    const { data: response, isLoading } = useOne<T>({\n        resource,\n        id,\n    });\n\n    const data = response?.data as any;\n\n    return isLoading ? <>{'loading...'}</> : <>{data[fieldToShow]}</>;\n}\n\nexport { JoinColumn }; //ManyToOne, OneToOne\n","import 'reflect-metadata';\n\nexport const keyMetadataKey = Symbol('key');\nexport const keyKey = 'key';\n\nexport function key(key: string) {\n    return Reflect.metadata(keyMetadataKey, key);\n}\n","import 'reflect-metadata';\n\nexport const renderMetadataKey = Symbol('renderTag');\nexport const renderKey = 'renderTag';\n\nexport function render(component: React.ComponentType) {\n    return Reflect.metadata(renderMetadataKey, component);\n}\n","import 'reflect-metadata';\n\n// TODO: revisar para qué está?\nexport const renderCellMetadataKey = Symbol('renderCell');\nexport function renderCell(renderFn: Function) {\n    return Reflect.metadata(renderCellMetadataKey, renderFn);\n}\n","import 'reflect-metadata';\n\nexport const titleMetadataKey = Symbol('title');\nexport const titleKey = 'title';\n\nexport function title(name: string) {\n    return Reflect.metadata(titleMetadataKey, name);\n}\n","import { ColumnTitle, ColumnType } from 'antd/es/table/interface';\nimport 'reflect-metadata';\nimport { dataIndexKey, dataIndexMetadataKey } from '../dataIndex.decorator';\nimport { keyMetadataKey, keyKey } from '../key.decorator';\nimport { titleMetadataKey, titleKey } from '../title.decorator';\n\nimport { DataIndex, Key } from 'rc-table/lib/interface';\nimport { Typography } from 'antd';\nimport { ShowComp } from './internal/components/ShowComp';\nimport { renderMetadataKey, renderKey } from '../render.decorator';\nimport { ComponentType, FunctionComponent } from 'react';\nimport { joinColumnKey, joinColumnMetadataKey } from '../joinColumn.decorator';\n\ntype Classable<T> = new (...args: any) => T;\ntype ShowComponentProps = { value: any; record: any; index?: number };\n\n// TODO: type each key interface\nenum EntityMetadataKeys {\n    ANTD_TABLE_COLUMNS = 'AntdTable:columns',\n    SHOW_COMPONENT = 'Show:component',\n}\n\ninterface AntdColumn<T> extends ColumnType<T> {\n    /**\n     * The Component to render when loading the Show view\n     *\n     * @privateRemarks\n     * TODO: check if this should change to a function that returns a ComponentType like refine's rendercell?\n     **/\n    renderTag?: ComponentType;\n}\n\ntype AntdTableColumns<T> = Record<string | symbol, AntdColumn<T>>;\n\ninterface AntdEntityOptions {\n    showComponent?: ComponentType<ShowComponentProps>;\n}\n\n/**\n * Marks the class as usable for Antd's components: Table's {@link '@antd/es/table/ColumnsType' | ColumnsType}, etc.\n * @decorators key, dataIndex, title, sorter, render\n **/\nexport function AntdEntity(options?: AntdEntityOptions): ClassDecorator;\n\n/**\n * TODO: make it dynamic in base of available decorators and it's according @{link '@antd/es/table/ColumnsType' | column} property [clickup #865bgjt0e]\n * TODO: extract each decorator get to its own function as with getFieldTitle() [clickup #865bh7p1x]\n **/\nexport function AntdEntity(\n    options: AntdEntityOptions = { showComponent: ShowComp }\n): ClassDecorator {\n    /**\n     * @param target - The class to which apply the decorator\n     * TODO: specify target's type -- possibly it could be something like FunctionConstructor, but it doesn't work straightforward, because a Class is indeed a Function under the hood - check if Classable works [clickup #865bh4t24]\n     **/\n    return function (entityClass: any) {\n        type EntityClassInstanceType = InstanceType<typeof entityClass>;\n        const decoratedClass = new entityClass();\n        const properties = Reflect.ownKeys(decoratedClass);\n        const columns: AntdTableColumns<EntityClassInstanceType> = {};\n\n        for (const property of properties) {\n            columns[property] = {};\n        }\n\n        for (const property of properties) {\n            let metadataValue: FunctionComponent | undefined = undefined;\n\n            if (\n                Reflect.hasMetadata(\n                    joinColumnMetadataKey,\n                    decoratedClass,\n                    property\n                )\n            ) {\n                metadataValue = Reflect.getMetadata(\n                    joinColumnMetadataKey,\n                    decoratedClass,\n                    property\n                );\n            }\n\n            const columnDefinition = columns[property];\n\n            columnDefinition[joinColumnKey] = metadataValue;\n        }\n\n        for (const property of properties) {\n            let metadataValue: DataIndex | undefined = undefined;\n\n            if (\n                Reflect.hasMetadata(\n                    dataIndexMetadataKey,\n                    decoratedClass,\n                    property\n                )\n            ) {\n                metadataValue = Reflect.getMetadata(\n                    dataIndexMetadataKey,\n                    decoratedClass,\n                    property\n                );\n            } else {\n                Reflect.defineMetadata(\n                    dataIndexMetadataKey,\n                    property,\n                    decoratedClass,\n                    property\n                );\n                metadataValue = property.toString();\n            }\n\n            const columnDefinition = columns[property];\n\n            columnDefinition[dataIndexKey] = metadataValue;\n        }\n\n        for (const property of properties) {\n            let metadataValue: Key | undefined = undefined;\n\n            if (Reflect.hasMetadata(keyMetadataKey, decoratedClass, property)) {\n                metadataValue = Reflect.getMetadata(\n                    keyMetadataKey,\n                    decoratedClass,\n                    property\n                );\n            } else {\n                Reflect.defineMetadata(\n                    keyMetadataKey,\n                    property,\n                    decoratedClass,\n                    property\n                );\n                metadataValue = property.toString();\n            }\n\n            const columnDefinition = columns[property];\n\n            columnDefinition[keyKey] = metadataValue;\n        }\n\n        for (const property of properties) {\n            let metadataValue = getFieldTitle(decoratedClass, property);\n            const columnDefinition = columns[property];\n\n            columnDefinition[titleKey] = metadataValue;\n        }\n\n        for (const property of properties) {\n            let metadataValue: React.ComponentType = Typography.Paragraph;\n\n            if (\n                Reflect.hasMetadata(renderMetadataKey, decoratedClass, property)\n            ) {\n                metadataValue = Reflect.getMetadata(\n                    renderMetadataKey,\n                    decoratedClass,\n                    property\n                );\n            } else {\n                Reflect.defineMetadata(\n                    renderMetadataKey,\n                    metadataValue,\n                    decoratedClass,\n                    property\n                );\n            }\n\n            const columnDefinition = columns[property];\n\n            columnDefinition[renderKey] = metadataValue;\n        }\n\n        Reflect.defineMetadata(\n            EntityMetadataKeys.ANTD_TABLE_COLUMNS,\n            columns,\n            entityClass\n        );\n\n        Reflect.defineMetadata(\n            EntityMetadataKeys.SHOW_COMPONENT,\n            { component: options.showComponent },\n            entityClass\n        );\n\n        return entityClass;\n    };\n}\n\n/**\n * @internal\n * Get metadata from an Entity.\n **/\nfunction getMetadata<T>(\n    key: EntityMetadataKeys,\n    clazz: Classable<T>\n): Readonly<Record<string | symbol, any>> {\n    /** trick to clone object without pointing to the same memory structure @see {@link https://stackoverflow.com/a/38122523/11865068} **/\n    return Object.assign({}, Reflect.getMetadata(key, clazz));\n}\n\n// TODO: explain what this 3 functions get as parameters, what returns and why. Whenever it's needed type the params, returns and expected arguments in calls. [clickup #865bgjt87]\nexport function antdEntityTableColumns<T>(\n    clazz: Classable<T>\n): ColumnType<T>[] {\n    return Object.values(\n        getMetadata(EntityMetadataKeys.ANTD_TABLE_COLUMNS, clazz) as Object\n    );\n}\n\n/**\n * Converts previously processed metadata into AntdTable type.\n **/\nexport function antdEntityGetColumns<T>(\n    clazz: Classable<T>\n): AntdTableColumns<T> {\n    return getMetadata(\n        EntityMetadataKeys.ANTD_TABLE_COLUMNS,\n        clazz\n    ) as AntdTableColumns<T>;\n}\n\nexport function antdEntityTableColumnsFromObj<T>(\n    obj: AntdColumn<T>\n): ColumnType<T>[] {\n    return Object.values(obj);\n}\n\n/**\n *\n * @param entityClass - The decorated class with the data properties to use\n * @param dataObject - The JSON comming from the dataprovider which should be an instance of entityClass or an extension of it\n **/\nexport function antdEntityGetShowFields<T extends Object>(\n    entityClass: Classable<T>,\n    dataObject?: T\n): ShowFieldsType<T> {\n    // TODO: refactor variables names [clickup #865bh33dg]\n    const showFields: ShowFieldsType = {};\n    let columnsMetadata = antdEntityGetColumns(entityClass);\n    const entityInstance = castDataObjectToSpecifiedType(\n        entityClass,\n        dataObject\n    ) as AntdTableColumns<T>;\n\n    const entityDefinedProperties = Reflect.ownKeys(columnsMetadata);\n\n    // TODO: {nice to have} This might be pre-computed and memoized instead of calling the function everytime the Show Fields need to be rendered.\n    for (const [index, property] of entityDefinedProperties.entries()) {\n        // TODO: refactor metadata\n        const propertyField: Partial<ShowFields<typeof entityClass>> = {\n            value: entityInstance[property],\n            /**\n             * TODO: Take component from metadata and if it's null use Paragraph as default (done). This behaviour must be in some other method that handles metadata for an object, including this component property as getFieldTitle(). [clickup #865bh7nn8]\n             * \t\t If property it's marked with @decorator `NotDisplay` component must be null.\n             * \t\t If property it's marked with @decorator `NotDisplay` the render method must be no-op.\n             * \t\t If property it's marked with @decorator `NotDisplay` the render method _probably_ should be sealed/freezed (impossible to change). Gather info about this, it may be possible for some cases that you wouldn't like to show a field in certain default cases but one would like to manage edge-cases manually, or show all fields nonetheless based on some flag (like debug).\n             * \t\t If property it's marked with @decorator `NotDisplay`, the objFields for the property must be complete nonetheless.\n             **/\n            metadata: Object.assign(\n                {},\n                { renderTag: Typography.Paragraph },\n                property in columnsMetadata ? columnsMetadata[property] : {}\n            ),\n        };\n\n        // TODO: make showComponent be any component type and handle rendering different instead of calling a render method\n        const definedComponent = getMetadata(\n            EntityMetadataKeys.SHOW_COMPONENT,\n            entityClass\n        ) as Record<any, any>;\n        const showComponent =\n            definedComponent.component as React.FC<ShowComponentProps>;\n\n        propertyField.render = () =>\n            showComponent({\n                value: entityInstance[property],\n                record: propertyField,\n                index,\n            });\n        showFields[property] = propertyField as ShowFields<typeof entityClass>;\n    }\n\n    return showFields;\n}\n\n/**\n * @internal\n * This converts dataObject to an instance of the entity to be able to get the entity metadata and properties\n **/\nfunction castDataObjectToSpecifiedType<T extends Object>(\n    entityClass: Classable<T>,\n    dataObject?: T\n) {\n    const entityInstance = new entityClass();\n    return Object.assign(entityInstance, dataObject);\n}\n\nexport interface ShowFields<RecordType> {\n    value: any;\n    render: (\n        value?: any,\n        record?: RecordType,\n        index?: number\n    ) => React.ReactNode | React.ReactNode;\n    // TODO: type metadata\n    metadata?: Record<any, any>;\n}\n\nexport type ShowFieldsType<RecordType extends object = any> = Record<\n    string | symbol,\n    ShowFields<RecordType>\n>;\n\n/**\n * @internal\n * Used to the information of a certain property of an object marked with the @{link title | title decorator}\n **/\nfunction getFieldTitle(objectClass: any, property: string | symbol) {\n    type TargetClassType = InstanceType<typeof objectClass>;\n    let metadataValue: ColumnTitle<TargetClassType> | undefined = undefined;\n\n    if (Reflect.hasMetadata(titleMetadataKey, objectClass, property)) {\n        metadataValue = Reflect.getMetadata(\n            titleMetadataKey,\n            objectClass,\n            property\n        );\n    } else {\n        Reflect.defineMetadata(\n            titleMetadataKey,\n            property,\n            objectClass,\n            property\n        );\n        metadataValue = property.toString();\n    }\n\n    return metadataValue;\n}\n","import { TextField } from '@refinedev/antd';\n\ntype ShowComponentProps = { value: any; record: any; index?: number };\n\n// TODO: refactor names. This component probably should mutate to something more general or based on the class metadata and definitions from decorators\n// TODO: edge case: props null\nexport const ShowComp: React.FC<ShowComponentProps> = (\n    props: ShowComponentProps,\n    context?: any\n) => {\n    const Componente = props.record?.metadata?.renderTag;\n\n    return (\n        <div key={props.record.key}>\n            <div style={{ backgroundColor: 'red' }}>\n                <TextField\n                    value={\n                        `${props.index} ` +\n                            (props.record?.metadata?.title &&\n                                props.record.metadata.title.toString()) ?? null\n                    }\n                />\n            </div>\n            <br />\n            {/**\n             * Componente references the React component defiend in the class Render decorator\n             */}\n            <Componente>\n                {(props.value && props.value.toString()) ?? null}\n            </Componente>\n        </div>\n    );\n};\n"],"mappings":"6iBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,gBAAAE,EAAA,eAAAC,EAAA,yBAAAC,EAAA,4BAAAC,EAAA,2BAAAC,EAAA,kCAAAC,EAAA,cAAAC,EAAA,iBAAAC,EAAA,yBAAAC,EAAA,kBAAAC,EAAA,0BAAAC,EAAA,QAAAC,EAAA,WAAAC,EAAA,mBAAAC,EAAA,WAAAC,EAAA,eAAAC,EAAA,0BAAAC,EAAA,cAAAC,EAAA,sBAAAC,EAAA,UAAAC,EAAA,aAAAC,EAAA,qBAAAC,IAAA,eAAAC,EAAAxB,GCAA,IAAAyB,GAAO,4BAEMC,EAAuB,OAAO,WAAW,EACzCC,EAAe,YAErB,SAASC,EAAUC,EAAiC,CACvD,OAAO,QAAQ,SAASH,EAAsBG,CAAI,CACtD,CCPA,IAAAC,GAAO,4BACPC,EAAyC,oBACzCC,EAAqD,2BAExCC,EAAwB,OAAO,YAAY,EAC3CC,EAAgB,SAE7B,SAASC,EACLC,EACAC,EACAC,EACAC,EACF,CACE,IAAMC,EAAUD,EAAWE,EAA0BC,EAC/CC,EAAiBC,GAAc,CACjC,IAAMC,EAA4B,CAAC,CAACD,EAAKP,CAAc,EAGjDS,EAFiB,CAAC,CAACF,EAAK,QAGR,CAACC,EACbD,EACAA,EAAKP,CAAc,EAC7B,OAAO,EAAAU,QAAM,cAAcP,EAAS,CAChC,SAAAJ,EACA,GAAAU,EACA,YAAAR,CACJ,CAAC,CACL,EAEA,OAAO,QAAQ,SAASL,EAAuBU,CAAa,CAChE,CAKA,SAASF,EAA8C,CACnD,SAAAL,EACA,GAAAU,EACA,YAAAR,CACJ,EAIgB,CACZ,GAAM,CAAE,KAAMU,EAAU,UAAAC,CAAU,KAAI,WAAW,CAC7C,SAAUb,EACV,IAAKU,CACT,CAAC,EAEKI,EAAOF,GAAA,YAAAA,EAAU,KAEjBG,EAAeD,GAAA,YAAAA,EAAM,IAAKE,GAAMA,EAAEd,CAAW,GAEnD,OAAOW,EAAY,EAAAF,QAAA,gBAAAA,QAAA,cAAG,YAAa,EAAM,EAAAA,QAAA,gBAAAA,QAAA,cAAGI,GAAA,YAAAA,EAAc,KAAK,KAAM,CACzE,CAKA,SAAST,EAAsC,CAC3C,SAAAN,EACA,GAAAU,EACA,YAAAR,CACJ,EAAqB,CACjB,GAAM,CAAE,KAAMU,EAAU,UAAAC,CAAU,KAAI,UAAU,CAC5C,SAAAb,EACA,GAAAU,CACJ,CAAC,EAEKI,EAAOF,GAAA,YAAAA,EAAU,KAEvB,OAAOC,EAAY,EAAAF,QAAA,gBAAAA,QAAA,cAAG,YAAa,EAAM,EAAAA,QAAA,gBAAAA,QAAA,cAAGG,EAAKZ,CAAW,CAAE,CAClE,CCxEA,IAAAe,GAAO,4BAEMC,EAAiB,OAAO,KAAK,EAC7BC,EAAS,MAEf,SAASC,EAAIA,EAAa,CAC7B,OAAO,QAAQ,SAASF,EAAgBE,CAAG,CAC/C,CCPA,IAAAC,GAAO,4BAEMC,EAAoB,OAAO,WAAW,EACtCC,EAAY,YAElB,SAASC,EAAOC,EAAgC,CACnD,OAAO,QAAQ,SAASH,EAAmBG,CAAS,CACxD,CCPA,IAAAC,GAAO,4BAGMC,EAAwB,OAAO,YAAY,EACjD,SAASC,EAAWC,EAAoB,CAC3C,OAAO,QAAQ,SAASF,EAAuBE,CAAQ,CAC3D,CCNA,IAAAC,GAAO,4BAEMC,EAAmB,OAAO,OAAO,EACjCC,EAAW,QAEjB,SAASC,EAAMC,EAAc,CAChC,OAAO,QAAQ,SAASH,EAAkBG,CAAI,CAClD,CCNA,IAAAC,GAAO,4BAMP,IAAAC,EAA2B,gBCP3B,IAAAC,EAA0B,2BAMbC,EAAyC,CAClDC,EACAC,IACC,CATL,IAAAC,EAAAC,EAAAC,EAAAC,EAUI,IAAMC,GAAaH,GAAAD,EAAAF,EAAM,SAAN,YAAAE,EAAc,WAAd,YAAAC,EAAwB,UAE3C,OACI,oBAAC,OAAI,IAAKH,EAAM,OAAO,KACnB,oBAAC,OAAI,MAAO,CAAE,gBAAiB,KAAM,GACjC,oBAAC,aACG,MACI,GAAGA,EAAM,YACJK,GAAAD,EAAAJ,EAAM,SAAN,YAAAI,EAAc,WAAd,YAAAC,EAAwB,QACrBL,EAAM,OAAO,SAAS,MAAM,SAAS,GAErD,CACJ,EACA,oBAAC,SAAG,EAIJ,oBAACM,EAAA,MACKN,EAAM,OAASA,EAAM,MAAM,SAAS,IAAM,IAChD,CACJ,CAER,EDgBO,SAASO,EACZC,EAA6B,CAAE,cAAeC,CAAS,EACzC,CAKd,OAAO,SAAUC,EAAkB,CAE/B,IAAMC,EAAiB,IAAID,EACrBE,EAAa,QAAQ,QAAQD,CAAc,EAC3CE,EAAqD,CAAC,EAE5D,QAAWC,KAAYF,EACnBC,EAAQC,CAAQ,EAAI,CAAC,EAGzB,QAAWA,KAAYF,EAAY,CAC/B,IAAIG,EAGA,QAAQ,YACJC,EACAL,EACAG,CACJ,IAEAC,EAAgB,QAAQ,YACpBC,EACAL,EACAG,CACJ,GAGJ,IAAMG,EAAmBJ,EAAQC,CAAQ,EAEzCG,EAAiBC,CAAa,EAAIH,EAGtC,QAAWD,KAAYF,EAAY,CAC/B,IAAIG,EAGA,QAAQ,YACJI,EACAR,EACAG,CACJ,EAEAC,EAAgB,QAAQ,YACpBI,EACAR,EACAG,CACJ,GAEA,QAAQ,eACJK,EACAL,EACAH,EACAG,CACJ,EACAC,EAAgBD,EAAS,SAAS,GAGtC,IAAMG,EAAmBJ,EAAQC,CAAQ,EAEzCG,EAAiBG,CAAY,EAAIL,EAGrC,QAAWD,KAAYF,EAAY,CAC/B,IAAIG,EAEA,QAAQ,YAAYM,EAAgBV,EAAgBG,CAAQ,EAC5DC,EAAgB,QAAQ,YACpBM,EACAV,EACAG,CACJ,GAEA,QAAQ,eACJO,EACAP,EACAH,EACAG,CACJ,EACAC,EAAgBD,EAAS,SAAS,GAGtC,IAAMG,EAAmBJ,EAAQC,CAAQ,EAEzCG,EAAiBK,CAAM,EAAIP,EAG/B,QAAWD,KAAYF,EAAY,CAC/B,IAAIG,EAAgBQ,EAAcZ,EAAgBG,CAAQ,EACpDG,EAAmBJ,EAAQC,CAAQ,EAEzCG,EAAiBO,CAAQ,EAAIT,EAGjC,QAAWD,KAAYF,EAAY,CAC/B,IAAIG,EAAqC,aAAW,UAGhD,QAAQ,YAAYU,EAAmBd,EAAgBG,CAAQ,EAE/DC,EAAgB,QAAQ,YACpBU,EACAd,EACAG,CACJ,EAEA,QAAQ,eACJW,EACAV,EACAJ,EACAG,CACJ,EAGJ,IAAMG,EAAmBJ,EAAQC,CAAQ,EAEzCG,EAAiBS,CAAS,EAAIX,EAGlC,eAAQ,eACJ,oBACAF,EACAH,CACJ,EAEA,QAAQ,eACJ,iBACA,CAAE,UAAWF,EAAQ,aAAc,EACnCE,CACJ,EAEOA,CACX,CACJ,CAMA,SAASiB,EACLC,EACAC,EACsC,CAEtC,OAAO,OAAO,OAAO,CAAC,EAAG,QAAQ,YAAYD,EAAKC,CAAK,CAAC,CAC5D,CAGO,SAASC,EACZD,EACe,CACf,OAAO,OAAO,OACVF,EAAY,oBAAuCE,CAAK,CAC5D,CACJ,CAKO,SAASE,EACZF,EACmB,CACnB,OAAOF,EACH,oBACAE,CACJ,CACJ,CAEO,SAASG,EACZC,EACe,CACf,OAAO,OAAO,OAAOA,CAAG,CAC5B,CAOO,SAASC,EACZxB,EACAyB,EACiB,CAEjB,IAAMC,EAA6B,CAAC,EAChCC,EAAkBN,EAAqBrB,CAAW,EAChD4B,EAAiBC,EACnB7B,EACAyB,CACJ,EAEMK,EAA0B,QAAQ,QAAQH,CAAe,EAG/D,OAAW,CAACI,EAAO3B,CAAQ,IAAK0B,EAAwB,QAAQ,EAAG,CAE/D,IAAME,EAAyD,CAC3D,MAAOJ,EAAexB,CAAQ,EAQ9B,SAAU,OAAO,OACb,CAAC,EACD,CAAE,UAAW,aAAW,SAAU,EAClCA,KAAYuB,EAAkBA,EAAgBvB,CAAQ,EAAI,CAAC,CAC/D,CACJ,EAOM6B,EAJmBhB,EACrB,iBACAjB,CACJ,EAEqB,UAErBgC,EAAc,OAAS,IACnBC,EAAc,CACV,MAAOL,EAAexB,CAAQ,EAC9B,OAAQ4B,EACR,MAAAD,CACJ,CAAC,EACLL,EAAWtB,CAAQ,EAAI4B,EAG3B,OAAON,CACX,CAMA,SAASG,EACL7B,EACAyB,EACF,CACE,IAAMG,EAAiB,IAAI5B,EAC3B,OAAO,OAAO,OAAO4B,EAAgBH,CAAU,CACnD,CAsBA,SAASZ,EAAcqB,EAAkB9B,EAA2B,CAEhE,IAAIC,EAEJ,OAAI,QAAQ,YAAY8B,EAAkBD,EAAa9B,CAAQ,EAC3DC,EAAgB,QAAQ,YACpB8B,EACAD,EACA9B,CACJ,GAEA,QAAQ,eACJ+B,EACA/B,EACA8B,EACA9B,CACJ,EACAC,EAAgBD,EAAS,SAAS,GAG/BC,CACX","names":["src_exports","__export","AntdEntity","JoinColumn","antdEntityGetColumns","antdEntityGetShowFields","antdEntityTableColumns","antdEntityTableColumnsFromObj","dataIndex","dataIndexKey","dataIndexMetadataKey","joinColumnKey","joinColumnMetadataKey","key","keyKey","keyMetadataKey","render","renderCell","renderCellMetadataKey","renderKey","renderMetadataKey","title","titleKey","titleMetadataKey","__toCommonJS","import_reflect_metadata","dataIndexMetadataKey","dataIndexKey","dataIndex","name","import_reflect_metadata","import_react","import_core","joinColumnMetadataKey","joinColumnKey","JoinColumn","resource","identification","fieldToShow","multiple","element","JoinColumnMultipleFetch","JoinColumnFetch","returnElement","item","hasIdentificationProperty","id","React","response","isLoading","data","filteredData","x","import_reflect_metadata","keyMetadataKey","keyKey","key","import_reflect_metadata","renderMetadataKey","renderKey","render","component","import_reflect_metadata","renderCellMetadataKey","renderCell","renderFn","import_reflect_metadata","titleMetadataKey","titleKey","title","name","import_reflect_metadata","import_antd","import_antd","ShowComp","props","context","_a","_b","_c","_d","Componente","AntdEntity","options","ShowComp","entityClass","decoratedClass","properties","columns","property","metadataValue","joinColumnMetadataKey","columnDefinition","joinColumnKey","dataIndexMetadataKey","dataIndexKey","keyMetadataKey","keyKey","getFieldTitle","titleKey","renderMetadataKey","renderKey","getMetadata","key","clazz","antdEntityTableColumns","antdEntityGetColumns","antdEntityTableColumnsFromObj","obj","antdEntityGetShowFields","dataObject","showFields","columnsMetadata","entityInstance","castDataObjectToSpecifiedType","entityDefinedProperties","index","propertyField","showComponent","objectClass","titleMetadataKey"]}